---
description: backend
alwaysApply: false
---
# Reglas de Cursor para Backend

## Arquitectura y Patrones

### Clean Architecture / Domain-Driven Design (DDD)
- Seguir estrictamente la separación en capas: Domain, Application, Infrastructure
- El Domain debe ser independiente de frameworks y librerías externas
- Usar interfaces (contratos) para desacoplar capas
- Implementar el patrón Repository para acceso a datos
- Usar Unit of Work para transacciones
- Implementar Domain Events para comunicación entre agregados

### Estructura de Proyectos (ASP.NET por Capas)
- **Proyecto por Capa**: Cada capa debe ser un proyecto separado de ASP.NET
- **Organización por Módulos**: Dentro de cada servicio hay módulos (ej: `Presunciones` es un módulo dentro de `Importacion`, `Songs` es un módulo dentro de `MusicBingo`)
- `Domain`: Entidades, Value Objects, Eventos, Excepciones, Servicios de dominio, Contratos
- `Application`: Use Cases, DTOs, Interfaces de aplicación, Handlers
- `Infrastructure`: Implementaciones de repositorios, servicios externos, persistencia, configuración EF
- `Worker`: Procesos en background (Background Services) **[Opcional]**
- `Migrations`: Migraciones de base de datos (proyecto separado)
- `API`: Controladores, Middleware, Configuración de servicios (opcional, si se requiere API explícita)

## Convenciones de Código

### Principio de Simplicidad
- **KISS (Keep It Simple, Stupid)**: Priorizar código simple y directo
- **Evitar sobre-ingeniería**: No agregar complejidad innecesaria
- **Iterativo**: Empezar simple y agregar complejidad solo cuando sea necesario
- **Consistencia**: Seguir el patrón establecido en el proyecto existente
- **Menos es más**: Preferir implementaciones concisas sobre extensas
- **Ejemplo de evolución**:
  ```csharp
  // ❌ SOBRE-COMPLICADO (primera iteración)
  public class PresuncionImagenes : ListValueObject<PresuncionImagenId>
  {
      // 50+ líneas con múltiples métodos, documentación XML excesiva,
      // métodos específicos de Digimax, propiedades adicionales...
  }
  
  // ✅ SIMPLE Y DIRECTO (iteración final)
  public record PresuncionImagenes : ListValueObject<PresuncionImagenId>
  {
      public static readonly int MaxImages = 5;
      public static readonly int MinImages = 1;

      public PresuncionImagenes(IReadOnlyList<PresuncionImagenId> Value) : base(Value)
      {
          EnsureMinImages(Value);
          EnsureMaxImages(Value);
      }

      private static void EnsureMinImages(IReadOnlyList<PresuncionImagenId> value)
      {
          if (value.Count < MinImages)
          {
              throw InvalidPresuncionImagenesException.CreateMinImages(MinImages, value.Count);
          }
      }

      private static void EnsureMaxImages(IReadOnlyList<PresuncionImagenId> value)
      {
          if (value.Count > MaxImages)
          {
              throw InvalidPresuncionImagenesException.CreateMaxImages(MaxImages, value.Count);
          }
      }
  }
  ```

### Nomenclatura
- **Entidades**: PascalCase (ej: `PresuncionVelocidad`, `Imagen`)
- **Value Objects**: PascalCase con sufijo descriptivo (ej: `PresuncionId`, `ImagenNombre`)
- **Interfaces**: Prefijo "I" + PascalCase (ej: `IPresuncionRepository`, `IImagenStore`)
- **Use Cases**: PascalCase + sufijo "UseCase" (ej: `ImportPresuncionDigimaxUseCase`)
- **Eventos**: PascalCase + sufijo "Event" (ej: `ImagenCreatedDomainEvent`)
- **Excepciones**: PascalCase + sufijo "Exception" (ej: `InvalidDigimaxImageCountException`)
- **Servicios**: PascalCase + sufijo descriptivo (ej: `ImagenStore`, `PresuncionFinder`)

### Value Objects
- Heredar de `StringValueObject`, `UuidValueObject`, `FloatValueObject`, etc. del SharedKernel
- Implementar validaciones en el constructor
- Usar métodos `Ensure*` para validaciones específicas
- **Lanzar excepciones de dominio personalizadas**, NO `ArgumentException`
- Mensajes de error en español
- **PREFIJO DE ENTIDAD**: Los Value Objects deben tener prefijo del nombre de la entidad para evitar colisiones
- **Nomenclatura**: `{Entidad}{Concepto}` (ej: `SongId`, `SongName`, `SongPlaylistId` en lugar de `PlaylistId`)
- **Cuándo aplicar**: Cuando el Value Object representa un concepto específico de una entidad
- **Cuándo NO aplicar**: Cuando el Value Object es genérico y se reutiliza entre múltiples entidades (ej: `Email`, `Money`, `Address`)

- **Ejemplo INCORRECTO** (sin prefijo de entidad):
```csharp
// ❌ INCORRECTO - Colisión de nombres
public sealed record PlaylistId : UuidValueObject  // En módulo Songs
public sealed record PlaylistId : UuidValueObject  // En módulo Playlists - ¡COLISIÓN!
```

- **Ejemplo CORRECTO** (con prefijo de entidad):
```csharp
// ✅ CORRECTO - Sin colisiones
public sealed record SongPlaylistId : UuidValueObject    // En módulo Songs
public sealed record PlaylistId : UuidValueObject        // En módulo Playlists
public sealed record SongId : UuidValueObject            // En módulo Songs
public sealed record SongName : StringValueObject        // En módulo Songs
public sealed record PlaylistName : StringValueObject    // En módulo Playlists
public sealed record PlaylistCoverUrl : StringValueObject // En módulo Playlists

// ✅ CORRECTO - Value Objects genéricos (sin prefijo)
public sealed record Email : StringValueObject           // Reutilizable
public sealed record Money : DecimalValueObject          // Reutilizable
public sealed record Address : StringValueObject          // Reutilizable
```

- Ejemplo de implementación:
```csharp
public sealed record ImagenNombre : StringValueObject
{
    private const int MinLength = 1;
    private const int MaxLength = 255;

    public ImagenNombre(string value) : base(value)
    {
        EnsureMinLength(value);
        EnsureMaxLength(value);
        EnsureValidFormat(value);
    }

    private static void EnsureMaxLength(string value)
    {
        if (value.Length > MaxLength)
        {
            throw new InvalidImagenNombreException($"El nombre de la imagen no puede exceder {MaxLength} caracteres");
        }
    }
}
```

### Entidades
- Heredar de `AggregateRoot` del SharedKernel
- Propiedades inmutables con `get;` o `get; private set;`
- Constructor privado para encapsulación
- Método estático `Create()` para creación de instancias
- Método `Delete()` que registra eventos de dominio
- Usar Value Objects para propiedades complejas
- **Registrar eventos de dominio**: Usar `RecordDomainEvent()` en métodos `Create()`, `Update()`, `Delete()`
- **Eventos automáticos**: Los eventos se almacenan en `_domainEvents` y se recuperan con `PullDomainEvents()`

### Use Cases
- Usar inyección de dependencias en el constructor
- **Dos métodos públicos**: `Execute()` para infraestructura (logging, try-catch) y método específico para lógica principal
- **Separación de responsabilidades**: `Execute()` maneja concerns de infraestructura, método principal maneja lógica de negocio
- **Manejo de errores**: TODO para implementar logging y try-catch en `Execute()`
- **Orden de operaciones**:
  1. Validaciones de dominio (usar Finders)
  2. Lógica de negocio y creación de entidades
  3. Guardar en repositorio (`_repository.Create()`)
  4. Publicar eventos de dominio (`_eventBus.Publish(aggregate.PullDomainEvents())`)
  5. Confirmar transacción (`_unitOfWork.SaveChangesAsync()`)
- **Ejemplo de estructura**:
```csharp
public async Task<Entity> Execute(Request request)
{
    //TODO: try catch, logging
    return await Create(request);
}

public async Task<Entity> Create(Request request)
{
    await _finder.FindOrFail(request.Id);
    
    var entity = Entity.Create(...);
    
    await _repository.Create(entity);
    await _eventBus.Publish(entity.PullDomainEvents());
    await _unitOfWork.SaveChangesAsync();
    
    return entity;
}
```

### DTOs (Data Transfer Objects)
- **Ubicación**: En la misma carpeta del Use Case que los utiliza
- **Nomenclatura**: `{UseCase}Request`, `{UseCase}Response`, `{Entidad}DTO`
- **Inmutabilidad**: Usar `record` para DTOs inmutables
- **Un archivo por DTO**: Separar cada DTO en su propio archivo
- **Documentación XML**: Incluir documentación para DTOs públicos
- **Propiedades primitivas**: Usar tipos primitivos (string, int, bool, etc.) en lugar de Value Objects
- **Ejemplo**:
```csharp
// CreateCageRequest.cs
/// <summary>
/// Request para crear una jaula.
/// </summary>
public record CreateCageRequest(
    string Id,
    string Name,
    string PlaylistId
);

// CreateCageResponse.cs
/// <summary>
/// Response de la creación de una jaula.
/// </summary>
public record CreateCageResponse(
    string Id,
    string Name,
    string PlaylistId,
    DateTime CreatedAt
);
```
- Ejemplo:
```csharp
public class ImportPresuncionDigimaxUseCase(
    IPresuncionRepository repository,
    IUnitOfWork unitOfWork,
    IEventBus eventBus,
    IGuidGenerator guidGenerator
)
{
    public async Task Execute(string compressedFileSourcePath)
    {
        try
        {
            var id = _guidGenerator.GenerateGuid().ToString();
            var presuncion = PresuncionVelocidad.ImportFromDigimax(id, compressedFileSourcePath);

            await _repository.Create(presuncion);
            await _eventBus.Publish(presuncion.PullDomainEvents());
            await _unitOfWork.SaveChangesAsync();
        }
        catch (Exception)
        {
            _eventBus.Publish(new ImportPresuncionDigimaxFailedEvent(compressedFileSourcePath));
        }
    }
}
```

### Excepciones de Dominio
- Heredar de `DomainException` del SharedKernel
- Incluir documentación XML completa
- Implementar constructores con mensaje y excepción interna
- **PATRÓN .Create**: Crear métodos estáticos `Create()` para casos específicos
- Mensajes descriptivos en español
- **Para Value Objects**: Crear excepciones específicas por cada tipo de validación
- **Para reglas de negocio**: Crear excepciones específicas por cada regla
- **Métodos Factory**: Usar métodos `Create*()` específicos para cada tipo de validación
- Ejemplo para Value Object:
```csharp
/// <summary>
/// Excepción que se lanza cuando el nombre de imagen no es válido.
/// </summary>
public class InvalidImagenNombreException : DomainException
{
    public InvalidImagenNombreException(string message) : base(message) { }
    
    public static InvalidImagenNombreException CreateForMaxLength(int maxLength)
    {
        return new InvalidImagenNombreException(
            $"El nombre de la imagen no puede exceder {maxLength} caracteres");
    }
}
```

- Ejemplo para regla de negocio:
```csharp
/// <summary>
/// Excepción que se lanza cuando el número de imágenes de una presunción Digimax no cumple con los requisitos.
/// </summary>
public class InvalidDigimaxImageCountException : DomainException
{
    public InvalidDigimaxImageCountException(string message) : base(message) { }
    
    public static InvalidDigimaxImageCountException Create(int expectedCount, int actualCount)
    {
        return new InvalidDigimaxImageCountException(
            $"Los radares Digimax deben capturar exactamente {expectedCount} imágenes por presunción. Se encontraron {actualCount} imágenes.");
    }
}
```

- **Ejemplo de múltiples métodos Create** para diferentes tipos de validación:
```csharp
/// <summary>
/// Excepción que se lanza cuando las imágenes de una presunción no cumplen con los requisitos.
/// </summary>
public sealed class InvalidPresuncionImagenesException : DomainException
{
    public InvalidPresuncionImagenesException(string message) : base(message) { }

    public static InvalidPresuncionImagenesException CreateMinImages(int minImages, int actualCount)
    {
        return new InvalidPresuncionImagenesException(
            $"Una presunción debe tener al menos {minImages} imagen. Se encontraron {actualCount} imágenes.");
    }
}
```

- **Uso en Value Objects**:
```csharp
private static void EnsureMinImages(IReadOnlyList<PresuncionImagenId> value)
{
    if (value.Count < MinImages)
    {
        throw InvalidPresuncionImagenesException.CreateMinImages(MinImages, value.Count);
    }
}
```

### Eventos de Dominio
- **Heredar de `DomainEvent`** del SharedKernel
- **Usar `sealed record`** para eventos inmutables
- **Propiedades `required`** para datos obligatorios con `init`
- **Override `MessageName`** con formato: `"{nombreproyecto}.{servicio}.{entidad}.{accion}"`
- Incluir todos los datos relevantes para el evento
- **Nomenclatura**: `{Entidad}{Accion}DomainEvent`
- Agrupar eventos relacionados en carpetas (ej: `Velocidad/`, `Cage/`)
- **Eventos de Fallo**: Organizar eventos de fallo en carpeta `Events/Failure/` para separarlos de eventos de éxito
- **Eventos de Compensación**: Los eventos de fallo deben activar mecanismos de compensación (rollback)
- **SOLO TIPOS PRIMITIVOS**: Los eventos de dominio SOLO deben transportar tipos primitivos (string, int, bool, DateTime, Guid, etc.)
- **PROHIBIDO**: NO usar Value Objects en eventos de dominio, siempre extraer el valor primitivo (.Value)
- Ejemplo:
```csharp
public sealed record ImagenCreatedDomainEvent() : DomainEvent
{
    public required string ImagenId { get; init; }        // ✅ Primitivo
    public required string Ruta { get; init; }            // ✅ Primitivo
    public required float Peso { get; init; }             // ✅ Primitivo
    public required string Nombre { get; init; }          // ✅ Primitivo
    public required string PresuncionId { get; init; }    // ✅ Primitivo

    public override string MessageName => "{nombreproyecto}.importacion.imagenes.created";
}
```

- Ejemplo INCORRECTO:
```csharp
public sealed record SongDrewFromCageEvent() : DomainEvent
{
    public required SongId SongId { get; init; }              // ❌ PROHIBIDO - Value Object
    public required PlaylistId PlaylistId { get; init; }      // ❌ PROHIBIDO - Value Object
    public required SongName SongName { get; init; }          // ❌ PROHIBIDO - Value Object
}
```

- Ejemplo CORRECTO:
```csharp
public sealed record SongDrewFromCageEvent() : DomainEvent
{
    public required Guid SongId { get; init; }                // ✅ CORRECTO - Primitivo
    public required Guid PlaylistId { get; init; }            // ✅ CORRECTO - Primitivo
    public required string SongName { get; init; }            // ✅ CORRECTO - Primitivo
    public required string ArtistName { get; init; }          // ✅ CORRECTO - Primitivo
    public required int DurationSeconds { get; init; }        // ✅ CORRECTO - Primitivo
    public required DateTime DrewAt { get; init; }            // ✅ CORRECTO - Primitivo
}
```

### Manejo de Eventos
- **Registrar eventos**: Usar `RecordDomainEvent()` en entidades
- **Publicar eventos**: Usar `_eventBus.Publish()` en Use Cases
- **EventBus**: Implementado con MassTransit para mensajería
- **Routing**: Los eventos usan `MessageName` como routing key
- **Logging**: EventBus incluye logging de eventos publicados
- **Pull events**: Usar `presuncion.PullDomainEvents()` para obtener y limpiar eventos
- **Orden**: Publicar eventos DESPUÉS de guardar en repositorio pero ANTES de `SaveChangesAsync()`
- **Manejo de errores**: Publicar eventos de fallo en catch blocks

### Eventos de Fallo y Compensación
- **Organización**: Colocar eventos de fallo en carpeta `Events/Failure/` dentro de cada módulo
- **Nomenclatura**: `{Entidad}{Accion}FailedEvent` (ej: `PresuncionImportFailedEvent`)
- **Propósito**: Activar mecanismos de compensación (rollback) cuando fallan operaciones
- **Datos mínimos**: Solo incluir información esencial para la compensación (IDs, rutas, etc.)
- **Sin detalles técnicos**: NO incluir excepciones ni mensajes de error en los eventos
- **Handlers de compensación**: Crear handlers específicos que ejecuten casos de uso de limpieza
- **Ubicación de handlers**: Los handlers de compensación van en la carpeta del caso de uso que ejecutan

### Handlers (Consumers de Eventos)
- **Implementar `IConsumer<TEvent>`** de MassTransit
- **Siempre llamar al Use Case** correspondiente en el método `Consume()`
- **Inyección directa del Use Case** en el constructor
- **Extraer datos del evento** usando `context.Message.PropertyName`
- **Nomenclatura simplificada**: `{Accion}On{Evento}` (ej: `ImportOnPresuncionDigimaxUploaded`, `PickOnSongPickedFromCage`)
- **Simplificar nombres de acciones**: Usar verbos simples como `Import`, `Store`, `Process`, `Check`
- **Evitar verbos complejos**: Preferir `Import` en lugar de `ImportProcess`, `Store` en lugar de `StoreOperation`
- **Documentación XML** completa para describir el propósito del handler
- Ejemplo:
```csharp
/// <summary>
/// Event handler que reacciona al evento PresuncionDigimaxUploadedEvent.
/// Este handler inicia el proceso de importación de presunciones Digimax
/// cuando se detecta que un archivo comprimido ha sido subido.
/// </summary>
public class ImportOnPresuncionDigimaxUploaded(
    ImportPresuncionDigimaxUseCase importPresuncionDigimaxUseCase
) : IConsumer<PresuncionDigimaxUploadedEvent>
{
    private readonly ImportPresuncionDigimaxUseCase _importPresuncionDigimaxUseCase = importPresuncionDigimaxUseCase;
    
    public async Task Consume(ConsumeContext<PresuncionDigimaxUploadedEvent> context)
    {
        await _importPresuncionDigimaxUseCase.Execute(context.Message.CompressedFileSourcePath);
    }
}
```

### Nomenclatura de Acciones en Event Handlers
- **Acciones básicas**: `Create`, `Update`, `Delete`
- **Acciones de proceso**: `Import`, `Export`, `Process`, `Pick`
- **Acciones de almacenamiento**: `Store`, `Save`, `Upload`
- **Acciones de verificación**: `Check`, `Validate`, `Verify`
- **Acciones de compresión**: `Compress`, `Decompress`
- **Acciones de fallo**: `Handle`, `Manage` (para manejo de errores)
- **Evitar**: `ImportProcess`, `StoreOperation`, `CheckValidation`
- **Preferir**: `Import`, `Store`, `Check`

### Handlers HTTP (API Controllers)
- **Heredar de `ControllerBase`**
- **Inyección directa del Use Case** en el constructor
- **Mapear parámetros HTTP** a DTOs del Use Case
- **Siempre llamar al Use Case** en el método de acción
- **Nomenclatura**: `{Accion}{Entidad}Handler`
- Ejemplo:
```csharp
[ApiController]
[Route("fuentes")]
public class CreateFuenteFtpHandler(CreateFuenteFtpUseCase useCase) : ControllerBase
{
    [HttpPost("{id:guid}")]
    public async Task<IActionResult> Post(
        [FromRoute] Guid id, 
        [FromBody] CreateFuenteRequest data)
    {
        await useCase.Execute(new CreateFuenteFtpDTO(
            id.ToString(),
            data.Nombre,
            data.Descripcion,
            data.Host,
            data.Puerto,
            data.Usuario,
            data.Password
        ));
        return Created();
    }
}
```

### Background Services (Workers)
- **Heredar de `BackgroundService`**
- **Usar `IServiceScopeFactory`** para crear scope y obtener Use Cases
- **Llamar al Use Case** dentro del scope creado
- **Manejar `CancellationToken`** apropiadamente
- Ejemplo:
```csharp
public class CheckPresuncionFilesUploadedWorker(
    ILogger<CheckPresuncionFilesUploadedWorker> logger,
    IServiceScopeFactory serviceScopeFactory
) : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        using var scope = _serviceScopeFactory.CreateScope();
        var useCase = scope.ServiceProvider.GetRequiredService<CheckSourceDigimaxUseCase>();
        await useCase.Execute();
    }
}
```

### Servicios de Dominio
- Usar `sealed class` para servicios
- **Instanciación flexible**: Los servicios de dominio pueden instanciarse directamente o inyectarse según el caso
- **Instanciación directa**: Preferible cuando son clases concretas con lógica pura de negocio sin dependencias externas
- **Inyección de dependencias**: Útil cuando necesitas testear, mockear o cuando el servicio tiene dependencias complejas
- Métodos asíncronos para operaciones I/O
- Manejo de errores con try-catch
- **Ejemplo con instanciación directa** (recomendado para servicios simples):
```csharp
public class PickRandomSongUseCase
{
    private readonly CageFinder _cageFinder = new CageFinder(cageRepository);
    private readonly SongRandomizer _songRandomizer = new SongRandomizer(songRepository);
}
```
- **Ejemplo con inyección** (útil para testing o servicios complejos):
```csharp
public class PickRandomSongUseCase(ICageFinder cageFinder, ISongRandomizer songRandomizer)
{
    private readonly ICageFinder _cageFinder = cageFinder;
    private readonly ISongRandomizer _songRandomizer = songRandomizer;
}
```

### Finders (Servicios de Búsqueda)
- **Ubicación**: `Domain/{Modulo}/Services/`
- **Nomenclatura**: `{Entidad}Finder` (ej: `CageFinder`, `PlaylistFinder`)
- **Patrón consistente**: Todos los Finders siguen el mismo patrón
- **Método principal**: `FindOrFail(Id)` que lanza excepción si no encuentra
- **Instanciación directa**: Se instancian directamente en Use Cases
- **Excepciones específicas**: Cada Finder lanza su excepción específica
- **Ejemplo**:
```csharp
public class CageFinder(ICageRepository repository)
{
    private readonly ICageRepository _repository = repository;
    
    public async Task<Cage> FindOrFail(CageId id)
    {
        var cage = await _repository.Find(id);
        EnsureCageExists(cage, id);
        return cage!;
    }

    private void EnsureCageExists(Cage? cage, CageId id)
    {
        if (cage == null)
        {
            throw CageNotExistsException.CreateFromId(id.Value);
        }
    }   
}
```

## Configuración de Proyectos

### Archivos .csproj
- Target Framework: `net8.0`
- Habilitar `ImplicitUsings` y `Nullable`
- RootNamespace: `{NombreProyecto}.$(MSBuildProjectName.Replace(" ", "_"))`
- **Proyectos ASP.NET**: Usar `Microsoft.NET.Sdk.Web` para proyectos que requieren funcionalidad web
- **Proyectos de Librería**: Usar `Microsoft.NET.Sdk` para proyectos de dominio y aplicación
- Referencias a SharedKernel apropiadas
- **Dependencias entre capas**: 
  - Domain: Sin dependencias externas (solo SharedKernel.Domain)
  - Application: Depende de Domain
  - Infrastructure: Depende de Application y Domain
  - Worker/API: Dependen de todas las capas anteriores

### Namespaces
- Seguir la estructura: `{NombreProyecto}.{Servicio}.{Modulo}.{Carpeta}.{Subcarpeta}`
- **Organización por módulos**: Cada módulo tiene su propio namespace
- Ejemplo: `{NombreProyecto}.Importacion.Domain.Presunciones.ValueObjects`
- Ejemplo: `{NombreProyecto}.Importacion.Application.Presunciones.Digimax.UseCases`
- Ejemplo: `{NombreProyecto}.Importacion.Domain.Imagenes.Entities`

## Reglas Específicas

### Validaciones
- Todas las validaciones de negocio deben estar en el Domain
- Usar métodos privados estáticos con prefijo `Ensure` para validaciones
- **Value Objects**: Lanzar excepciones de dominio personalizadas, NO `ArgumentException`
- **Reglas de negocio**: Lanzar excepciones de dominio personalizadas específicas
- Crear excepciones específicas para cada tipo de validación (ej: `InvalidImagenNombreException`)

### Proceso de Desarrollo Iterativo
- **Empezar simple**: Implementar solo lo necesario para el caso de uso actual
- **Revisar y simplificar**: Después de cada implementación, preguntarse "¿se puede simplificar?"
- **Seguir patrones existentes**: Revisar código similar en el proyecto antes de crear algo nuevo
- **Evitar "feature creep"**: No agregar funcionalidades "por si acaso"
- **Refactoring continuo**: Simplificar código existente cuando se encuentre complejidad innecesaria
- **Preguntas clave**:
  - ¿Este código es realmente necesario?
  - ¿Hay una forma más simple de hacer esto?
  - ¿Sigue el patrón establecido en el proyecto?
  - ¿Se puede reducir el número de líneas sin perder funcionalidad?

### Organización de Carpetas y Reutilización
- **ANTES de crear nueva carpeta**: Verificar si ya existe una carpeta similar
- **Reutilizar estructura existente**: Agregar nuevos archivos a carpetas existentes cuando sea apropiado
- **Consistencia de ubicación**: Mantener archivos relacionados en la misma carpeta
- **Ejemplo CORRECTO**:
  ```
  RemoveDigimaxTempImages/
  ├── RemoveDigimaxTempImagesUseCase.cs
  ├── RemoveTempImagesOnDigimaxImagesStorageFailed.cs
  └── RemoveTempImagesOnDigimaxImagesStored.cs  ← Agregar aquí, no crear nueva carpeta
  ```
- **Ejemplo INCORRECTO**:
  ```
  RemoveDigimaxTempImages/          ← Carpeta existente
  ├── RemoveDigimaxTempImagesUseCase.cs
  └── RemoveTempImagesOnDigimaxImagesStorageFailed.cs
  
  RemoveTempImages/                 ← ❌ NO crear nueva carpeta innecesaria
  └── RemoveTempImagesOnDigimaxImagesStored.cs
  ```
- **Regla de oro**: Si ya existe una carpeta con funcionalidad similar, agregar el nuevo archivo ahí

### Manejo de Archivos
- Usar `Stream` para manipulación de archivos
- Implementar validación de extensiones permitidas
- Validar tamaños máximos de archivos
- Usar rutas relativas con estructura de fechas (yyyy/MM/dd)

### Expresiones Regulares
- Definir como constantes estáticas públicas cuando se reutilizan
- Usar grupos con nombres para extraer información
- Validar formato antes de procesar

### Fechas y Tiempo
- Usar `TimeProvider` para inyección de dependencias de tiempo
- Usar `DateTime.ParseExact()` con formatos específicos
- Considerar `CultureInfo.InvariantCulture` para parsing

### Inyección de Dependencias
- Usar constructor injection
- Registrar campos privados readonly para las dependencias
- Usar interfaces para todas las dependencias externas

## Buenas Prácticas

### Código
- Usar `sealed` para clases que no necesitan herencia
- Preferir `record` para Value Objects
- Usar `async/await` para operaciones asíncronas
- Implementar `using` statements para recursos desechables

### Documentación
- Incluir documentación XML para excepciones públicas
- Comentar lógica de negocio compleja
- Usar comentarios TODO para mejoras futuras

### Código Limpio
- **Eliminar comentarios obvios**: El código debe ser auto-documentado
- **Nombres expresivos**: Variables y métodos deben explicarse por sí mismos
- **Sin ruido visual**: Evitar comentarios que solo repiten lo que hace el código
- **Principio**: "El código debe ser suficientemente expresivo para no necesitar comentarios obvios"
- **Ejemplo INCORRECTO**:
```csharp
// 1. Validar que la playlist existe
await _playlistFinder.FindOrFail(new PlaylistId(request.PlaylistId));

// 2. Crear la jaula
var cage = Cage.Create(...);

// 3. Guardar en repositorio
await _cageRepository.Create(cage);
```
- **Ejemplo CORRECTO**:
```csharp
await _playlistFinder.FindOrFail(new PlaylistId(request.PlaylistId));

var cage = Cage.Create(...);

await _cageRepository.Create(cage);
```

### Performance
- Usar `IAsyncEnumerable` para streams grandes de datos
- Implementar paginación para consultas grandes
- Considerar caching para datos frecuentemente accedidos

## Estructura de Carpetas y Proyectos

### Estructura de Solución
```
Solution/
├── {NombreServicio}.Domain/           # Proyecto de librería (.NET 8.0)
├── {NombreServicio}.Application/      # Proyecto de librería (.NET 8.0)
├── {NombreServicio}.Infrastructure/   # Proyecto de librería (.NET 8.0)
├── {NombreServicio}.Worker/           # Proyecto ASP.NET (.NET 8.0 Web) [Opcional]
├── {NombreServicio}.Migrations/       # Proyecto de librería (.NET 8.0)
├── {NombreServicio}.API/              # Proyecto ASP.NET (.NET 8.0 Web) [Opcional]
└── SharedKernel/                      # Proyectos compartidos
    ├── SharedKernel.Domain/
    ├── SharedKernel.Application/
    └── SharedKernel.Infraestructure/
```

### Estructura Interna de Proyectos por Módulos
```
{Proyecto}/
├── {Modulo}/                    # Ej: Presunciones, Imagenes
│   ├── Contracts/               # Interfaces de repositorio y servicios
│   ├── Criteria/                # Criterios de búsqueda
│   ├── Entities/                # Entidades de dominio
│   ├── Events/                  # Eventos de dominio
│   │   ├── Failure/             # Eventos de fallo y compensación
│   │   └── {Subcategoria}/      # Eventos agrupados por funcionalidad (ej: Velocidad/)
│   ├── Exceptions/              # Excepciones específicas
│   ├── Services/                # Servicios de dominio
│   └── ValueObjects/            # Value Objects
├── {OtroModulo}/                # Ej: Imagenes
│   ├── Contracts/
│   ├── Criteria/
│   ├── Entities/
│   ├── Events/
│   ├── Exceptions/
│   ├── Services/
│   └── ValueObjects/
└── SharedKernel/                # Solo en Infrastructure
    └── Persistence/
```

### Ejemplo de Estructura Real
```
{NombreServicio}.Domain/
├── {Modulo1}/
│   ├── Contracts/
│   ├── Criteria/
│   ├── Entities/
│   ├── Events/
│   │   ├── Failure/             # Eventos de fallo (ej: {Entidad}ImportFailedEvent)
│   │   └── {Subcategoria}/      # Eventos específicos por funcionalidad
│   ├── Exceptions/
│   ├── Services/
│   └── ValueObjects/
├── {Modulo2}/
│   ├── Contracts/
│   ├── Criteria/
│   ├── Entities/
│   ├── Events/
│   │   └── Failure/             # Eventos de fallo del módulo
│   ├── Exceptions/
│   ├── Services/
│   └── ValueObjects/
└── SharedKernel/                # Solo en Infrastructure
    └── Persistence/
```

## Comandos y Consultas

- Seguir el patrón CQRS cuando sea apropiado
- Separar comandos (que modifican estado) de consultas (que solo leen)
- Usar Use Cases para comandos complejos
- Implementar handlers específicos para cada operación

## Logging y Monitoreo

- Usar structured logging
- Incluir correlation IDs para rastrear operaciones
- Logear eventos importantes del dominio
- Implementar health checks para servicios externos

## Patrones de Diseño Específicos

### Criteria Pattern (Patrón de Criterios)
- **Ubicación**: `Domain/{Modulo}/Criteria/`
- **Herencia**: Heredar de `BaseCriteria` del SharedKernel
- **Patrón Fluent**: Implementar métodos que retornen `this` para encadenamiento
- **Inmutabilidad**: `BaseCriteria` debe ser mutable para patrón fluent eficiente
- **Método Create()**: Agregar método estático `Create()` para instanciación limpia
- **Ejemplo**:
```csharp
public class SongCriteria : BaseCriteria
{
    public static SongCriteria Create() => new SongCriteria();
    
    public SongCriteria WithPlaylistId(SongPlaylistId playlistId)
    {
        AddFilter(new Filter("PlaylistId", FilterOperators.EQ, playlistId.Value));
        return this;
    }
    
    public SongCriteria Exclude(IEnumerable<SongId> songIds)
    {
        AddFilter(new Filter("Id", FilterOperators.NOT_IN, songIds.Select(x => x.Value)));
        return this;
    }
    
    public SongCriteria Paginate(int page, int pageSize)
    {
        base.Paginate(page, pageSize);
        return this;
    }
}
```

### Algoritmos de Selección Aleatoria
- **Thread-Safe**: Usar `Random.Shared.Next()` en lugar de `new Random()`
- **Eficiencia**: Obtener canciones disponibles primero, luego seleccionar aleatoriamente
- **Validación**: Verificar que hay elementos disponibles antes de seleccionar
- **Ejemplo CORRECTO**:
```csharp
public async Task<Song> GetRandomSongFromPlaylist(CageSongsDrawn alreadyDrawnSongs, CagePlaylistId playlistId)
{
    var criteria = new SongCriteria().Exclude(alreadyDrawnSongs.Value);
    var totalSongs = await _songRepository.CountSongsFromPlaylist(playlistId, criteria);
    var randomSongPosition = Random.Shared.Next(1, totalSongs + 1); // ✅ Thread-safe
    
    EnsurePlaylistHasRemainingSongs(totalSongs, playlistId);
    
    var songs = await _songRepository.GetSongsFromPlaylist(playlistId, criteria.Paginate(randomSongPosition, 1));
    return songs.First();
}
```

### Manejo de Dependencias en Use Cases
- **Dependencias externas**: Inyectar interfaces (repositorios, servicios externos)
- **Servicios de dominio**: Flexibilidad entre instanciación directa e inyección según necesidades
- **Eliminar dependencias no utilizadas**: No inyectar servicios que no se usan
- **Criterios para decidir**:
  - **Instanciación directa**: Servicios simples, lógica pura de negocio, sin dependencias complejas
  - **Inyección**: Necesidad de testing, mockeo, o servicios con dependencias complejas
- **Ejemplo con instanciación directa**:
```csharp
public class PickRandomSongUseCase(
    ICageRepository cageRepository,        // ✅ Interface - inyectar
    ISongRepository songRepository,        // ✅ Interface - inyectar
    IUnitOfWork unitOfWork,                // ✅ Interface - inyectar
    IEventBus eventBus                     // ✅ Interface - inyectar
)
{
    // ✅ Servicios de dominio - instanciar directamente (recomendado para casos simples)
    private readonly CageFinder _cageFinder = new CageFinder(cageRepository);
    private readonly SongRandomizer _songRandomizer = new SongRandomizer(songRepository);
}
```
- **Ejemplo con inyección** (para casos complejos o testing):
```csharp
public class PickRandomSongUseCase(
    ICageRepository cageRepository,
    ISongRepository songRepository,
    IUnitOfWork unitOfWork,
    IEventBus eventBus,
    ICageFinder cageFinder,                // ✅ Inyectar si necesitas testing/mockeo
    ISongRandomizer songRandomizer         // ✅ Inyectar si necesitas testing/mockeo
)
```

### Excepciones de Dominio Específicas
- **Crear excepciones específicas**: No usar `InvalidOperationException` genérica
- **Métodos factory**: Implementar métodos `Create()` con contexto específico
- **Mensajes descriptivos**: Incluir información relevante en el mensaje
- **Ejemplo**:
```csharp
public class EmptyPlaylistException : DomainException
{
    public EmptyPlaylistException(string message) : base(message) { }
    
    public static EmptyPlaylistException CreateFromPlaylistId(string playlistId)
    {
        return new EmptyPlaylistException($"La playlist {playlistId} no tiene canciones disponibles para extraer");
    }
}
```

### Validaciones en Value Objects
- **Validación automática**: Los Value Objects validan en constructor y métodos de modificación
- **No duplicar validaciones**: Si el Value Object ya valida, no validar en la entidad
- **Ejemplo**:
```csharp
public sealed record CageSongsDrawn : ListValueObject<SongId>
{
    public CageSongsDrawn(List<SongId> Value) : base(Value)
    {
        EnsureNoDuplicatedSongs(); // ✅ Valida automáticamente
    }
    
    public CageSongsDrawn Append(SongId songId)
    {
        return new CageSongsDrawn(Value.Append(songId).ToList()); // ✅ Valida automáticamente
    }
}

// ❌ NO validar en la entidad si el Value Object ya valida
public void PickSong(Song song)
{
    // if (DrawnSongs.Contains(song.Id)) // ❌ NO necesario - CageSongsDrawn ya valida
    DrawnSongs = DrawnSongs.Append(song.Id); // ✅ Esto ya valida duplicados
}
```

### Separación de Responsabilidades en Use Cases
- **Patrón de dos métodos**: `Execute()` para infraestructura, método específico para lógica
- **Execute()**: Maneja logging, try-catch, métricas, validaciones de infraestructura
- **Método específico**: Maneja puramente la lógica de negocio
- **Beneficios**:
  - Separación clara de concerns
  - Fácil testing de lógica de negocio
  - Reutilización del método específico
  - Manejo consistente de infraestructura
- **Estructura recomendada**:
```csharp
public async Task<Entity> Execute(Request request)
{
    //TODO: try catch, logging, métricas
    return await Create(request);
}

public async Task<Entity> Create(Request request)
{
    // Lógica pura de negocio
    await _finder.FindOrFail(request.Id);
    var entity = Entity.Create(...);
    await _repository.Create(entity);
    await _eventBus.Publish(entity.PullDomainEvents());
    await _unitOfWork.SaveChangesAsync();
    return entity;
}
```

**CONSTRUCTORES DE ENTIDADES**: Los constructores de entidades deben ser públicos para permitir la creación sin disparar eventos automáticamente. Solo el método `Create` estático debe disparar eventos de creación.

**CONSTRUCTORES CON PRIMITIVOS**: Los constructores y métodos `Create` de entidades deben recibir tipos primitivos (string, int, List<string>, etc.) y convertir internamente a Value Objects. NO recibir Value Objects directamente.

**IMPORTACIONES OBLIGATORIAS**: Siempre agregar todas las importaciones necesarias (`using`) al crear archivos. Incluir: SharedKernel, excepciones de dominio, Value Objects, y cualquier dependencia requerida.